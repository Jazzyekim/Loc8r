# Loc8r - a Playwright Locator Scanner (PoC)

A small Python console application that launches a Chromium browser using Playwright, lets you navigate to a page, and upon command scans for interactable elements, generating robust locators for each element: XPath, CSS, id (when available), Playwright role-based locators, and a human-friendly unique Name for each element.

Note: This proof-of-concept uses Playwright directly from Python. It is structured so it can be adapted to an MCP server/client flow if needed.

## Requirements
- Python 3.9+
- Playwright Python package and browser binaries

## Installation

1. Install dependencies:

```bash
pip install -e .
```

2. Install Playwright browser binaries (one-time):

```bash
python -m playwright install
```

## Usage

Run the console app:

```bash
loc8r
``` 
or
```bash
loc8
```

You will see a Chromium window open and a prompt in your terminal. Available commands:

- `url <https://...>` Navigate the opened page to a specific URL.
- `scan [output.json]` Scan current page for interactable elements and print best-effort unique locators (XPath, CSS, id, Playwright role) and a human-friendly unique Name. If `output.json` is provided, the JSON results will be saved to that file as well.
- `codegen <json> [PageName] [outDir]` Generate a Java Page Object (@FindBy, PageFactory) from a scan JSON. If `PageName` is omitted, you'll be prompted. `outDir` defaults to `src/test/java`.
- `help` Show commands.
- `quit` or `exit` Close the browser and exit.

Example session:

```
$ loc8
Loc8r Playwright Scanner
Commands:
  url <https://...>  -> navigate to a URL in the opened page
  scan               -> scan current page for interactable elements and print locators (XPath, CSS, id, role)
  help               -> show this help
  quit/exit          -> close browser and exit
Launching Chromium...
Browser launched. You can now type 'url <address>' to navigate, or manually navigate in the opened window.
loc8r> url https://example.com
loc8r> scan
Found 4 interactable elements:
#1: <a> text='More information'
    id: None
    xpath: //a[normalize-space(.)='More information']
    css: a[href]
    role: get_by_role('link', name='More information')
...
```

## How locator generation works (summary)

- id: If the element has an id and it is unique and NOT auto-generated, it is reported and used directly. Auto-generated ids (UUIDs, long hex strings, framework-generated like :r1:, ember123, etc.) are ignored.
- XPath: Prefer unique, non-autogenerated id; then strong attributes (`data-testid`, `data-test`, `data-qa`, `name`, `aria-label`, `title`); for links/buttons try text; for inputs try associated label; combine tag+attributes; try stable ancestor (ignoring autogenerated ids); fallback to an index.
- CSS: Prefer #id or [id="..."] only for non-autogenerated ids; try strong attributes; combine tag+attributes; narrow via stable ancestor (ignoring autogenerated ids); fallback to :nth-of-type under ancestor/body.
- Playwright role: Infer ARIA role (explicit role attribute or implicit from tag/type/href) and an accessible name (aria-label/title/alt/label or text). If `get_by_role(role, name=...)` is unique, it's reported.

Each candidate is validated for uniqueness against the live DOM before being accepted; otherwise, the builder proceeds to stronger/narrower options or safe fallbacks.

## Notes
- Increase default timeouts or adjust logic as needed for heavy/SPA pages.
- The scanner looks for typical interactable elements: links, buttons, inputs (non-hidden), selects, textareas, role=button, tabindex, and contenteditable=true.

---

## Generate Java Page Objects (PageFactory, @FindBy)
This project includes a simple code generator that converts scanned locator JSON into classic Selenium Page Object classes using @FindBy annotations.

Requirements:
- Jinja2 (added to project dependencies)

Usage:
```bash
# Using the dedicated CLI command (recommended)
loc8r-codegen \
  --input masha.json \
  --package com.example.pages \
  --class-name Login \
  --out src/test/java

# Directory of JSON scans (file stem will be used as page name if --class-name not given)
loc8r-codegen \
  --input scans/ \
  --package com.example.pages \
  --out src/test/java

# You can still use the module (alternative)
python -m locator_scanner.codegen_pf \
  --input masha.json \
  --package com.example.pages \
  --class-name Login \
  --out src/test/java
```

Options:
- --package: Java package for generated classes (default: com.example.pages)
- --class-name: Base page name (e.g., "Login"); class is named <Name>Page
- --out: Output root directory (default: src/test/java)
- --timeout-seconds: Wait timeout seconds (default: 5)
- --name-annotation-import: Fully-qualified @Name annotation import (default: com.example.annotations.Name)

Example output (given masha.json and --class-name Login):
```java
package com.example.pages;

import com.example.annotations.Name;
import org.openqa.selenium.*;
import org.openqa.selenium.support.*;
import org.openqa.selenium.support.ui.*;
import java.time.Duration;

@Name("Login")
public class LoginPage {
    private final WebDriver driver;
    private final Duration timeout = Duration.ofSeconds(5);

    @Name("Username")
    @FindBy(id = "user-name")
    private WebElement userName;

    @Name("Password")
    @FindBy(id = "password")
    private WebElement password;

    @Name("Login")
    @FindBy(css = "input[data-test='login-button']")
    private WebElement loginButton;

    public LoginPage(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
    }
}
```
